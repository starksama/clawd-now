<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>clawd: zzz...</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// â”€â”€ Easing Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ease = {
  linear: t => t,
  inQuad: t => t * t,
  outQuad: t => t * (2 - t),
  inOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  inCubic: t => t * t * t,
  outCubic: t => (--t) * t * t + 1,
  inOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  inElastic: t => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * ((2 * Math.PI) / 3)),
  outElastic: t => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1,
  outBounce: t => {
    const n1 = 7.5625, d1 = 2.75;
    if (t < 1 / d1) return n1 * t * t;
    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  },
};

// â”€â”€ Theme Color (user configurable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const THEME_BG = '#E8937C';  // Single background - change this to customize

// â”€â”€ Emotion Profiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// All states share same bg. Emotions via pixel art only (eyes, brows, mouth)
const PROFILES = {
  // ğŸ’¤ SLEEPING - Eyes almost closed, zzz particles
  sleeping: {
    eyeOpen: 0.08,
    mouthChance: 0,
    mouthType: 'neutral',
    bobSpeed: 0.006,
    bobAmount: 2,
    driftSpeed: 0.002,
    driftAmount: 1,
    blinkRate: 0.01,
    squintRate: 0,
    eventDelay: [300, 500],
    showZzz: true,
    blush: 0,
    squash: 1.0,
    eyebrows: 'none',
  },
  // ğŸ˜¶ IDLE - Relaxed, neutral expression
  idle: {
    eyeOpen: 1.0,
    mouthChance: 0.15,
    mouthType: 'neutral',
    bobSpeed: 0.012,
    bobAmount: 2,
    driftSpeed: 0.006,
    driftAmount: 2,
    blinkRate: 0.2,
    squintRate: 0.1,
    eventDelay: [100, 250],
    showZzz: false,
    blush: 0,
    squash: 1.0,
    eyebrows: 'none',
  },
  // ğŸ”’ FOCUSED - Squinted eyes, furrowed brows, minimal movement
  focused: {
    eyeOpen: 0.25,
    mouthChance: 0,
    mouthType: 'neutral',
    bobSpeed: 0.008,
    bobAmount: 0.8,
    driftSpeed: 0.002,
    driftAmount: 0.5,
    blinkRate: 0.05,
    squintRate: 0,
    eventDelay: [250, 450],
    showZzz: false,
    blush: 0,
    squash: 0.95,
    eyebrows: 'furrowed',
  },
  // ğŸ˜Š HAPPY - Wide eyes, raised brows, smile, blush
  happy: {
    eyeOpen: 1.0,
    mouthChance: 0.95,
    mouthType: 'smile',
    bobSpeed: 0.025,
    bobAmount: 4,
    driftSpeed: 0.015,
    driftAmount: 3,
    blinkRate: 0.25,
    squintRate: 0.05,
    eventDelay: [60, 140],
    showZzz: false,
    blush: 0.5,
    squash: 1.1,
    eyebrows: 'raised',
    showSparkles: true,
  },
  // ğŸ˜° STRESSED - Worried brows, sweat, jitter
  stressed: {
    eyeOpen: 0.6,
    mouthChance: 0.4,
    mouthType: 'worried',
    bobSpeed: 0.015,
    bobAmount: 1.5,
    driftSpeed: 0.01,
    driftAmount: 1,
    blinkRate: 0.35,
    squintRate: 0.15,
    eventDelay: [60, 120],
    showZzz: false,
    jitter: true,
    blush: 0,
    squash: 0.92,
    eyebrows: 'worried',
    showSweat: true,
  },
  // ğŸ’¬ TEXTING - Normal, attentive expression
  texting: {
    eyeOpen: 0.75,
    mouthChance: 0.2,
    mouthType: 'neutral',
    bobSpeed: 0.02,
    bobAmount: 1.5,
    driftSpeed: 0.004,
    driftAmount: 1,
    blinkRate: 0.2,
    squintRate: 0.05,
    eventDelay: [80, 180],
    showZzz: false,
    blush: 0,
    squash: 1.0,
    eyebrows: 'none',
  },
  // â˜• CHILLING - Relaxed happy, enjoying life
  chilling: {
    eyeOpen: 0.7,
    mouthChance: 0.8,
    mouthType: 'content',
    bobSpeed: 0.008,
    bobAmount: 1.5,
    driftSpeed: 0.004,
    driftAmount: 2,
    blinkRate: 0.15,
    squintRate: 0.2,
    eventDelay: [150, 300],
    showZzz: false,
    blush: 0.2,
    squash: 1.0,
    eyebrows: 'none',
  },
  // Legacy aliases - map to core states
  excited: null,  // â†’ happy
  tired: null,    // â†’ sleeping
  bored: null,    // â†’ idle
  curious: null,  // â†’ idle
  thinking: null, // â†’ focused
  angry: null,    // â†’ stressed
  inlove: null,   // â†’ happy
};

const EYE_COLOR = '#3D2817';  // Dark brown for pixel art face
const HEART_COLOR = '#CC2244';
const BLUSH_COLOR = 'rgba(255, 120, 140, ';
const SPARKLE_COLOR = '#FFE066';

// Heart pixel art (7x8)
const HEART_SHAPE = [
  [0,1,1,0,1,1,0],
  [1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1],
  [0,1,1,1,1,1,0],
  [0,1,1,1,1,1,0],
  [0,0,1,1,1,0,0],
  [0,0,0,1,0,0,0],
];

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let emotion = 'idle';
let task = 'Just vibing...';
let energy = 100;
let tick = 0;

let openness = 0.85;
let targetOpenness = 0.85;
let mouthShow = 0;
let targetMouth = 0;
let currentMouthType = 'neutral';

let nextEvent = 100;
let currentPhase = 'idle';

let currentProfile = { ...PROFILES.idle };
let targetProfile = PROFILES.idle;

// Particles
let particles = [];

// Smooth values for squash/stretch
let currentSquash = 1.0;
let targetSquash = 1.0;

// Screen shake
let shakeX = 0;
let shakeY = 0;

// Blush alpha
let currentBlush = 0;
let targetBlush = 0;

// â”€â”€ Auto-return to idle & Random Activities â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RETURN_TO_IDLE_MS = 2 * 60 * 1000; // 2 minutes
let lastSignalTime = Date.now();
let idleActivityTimer = null;

const IDLE_ACTIVITIES = [
  { task: 'Looking around... ğŸ‘€', duration: 3000 },
  { task: 'Stretching~ ğŸ™†', duration: 2500 },
  { task: 'Humming a tune ğŸµ', duration: 4000 },
  { task: 'Thinking about life ğŸ’­', duration: 3500 },
  { task: 'Daydreaming â˜ï¸', duration: 4000 },
  { task: 'Wiggling happily âœ¨', duration: 2000 },
  { task: 'Checking surroundings ğŸ”', duration: 3000 },
  { task: 'Taking a deep breath ğŸŒ¬ï¸', duration: 2500 },
  { task: 'Admiring the view ğŸŒ…', duration: 3500 },
  { task: 'Just existing ğŸ«§', duration: 3000 },
];

function scheduleIdleActivity() {
  if (idleActivityTimer) clearTimeout(idleActivityTimer);
  if (emotion !== 'idle') return;
  
  const delay = 5000 + Math.random() * 10000; // 5-15 seconds
  idleActivityTimer = setTimeout(() => {
    if (emotion === 'idle') {
      const activity = IDLE_ACTIVITIES[Math.floor(Math.random() * IDLE_ACTIVITIES.length)];
      task = activity.task;
      // Return to default after activity
      setTimeout(() => {
        if (emotion === 'idle') {
          task = 'Just vibing...';
        }
        scheduleIdleActivity();
      }, activity.duration);
    }
  }, delay);
}

function checkAutoReturn() {
  const now = Date.now();
  if (emotion !== 'idle' && emotion !== 'sleeping' && (now - lastSignalTime) > RETURN_TO_IDLE_MS) {
    setEmotion('idle');
    task = 'Back to vibing...';
    scheduleIdleActivity();
  }
}

// Check auto-return every 30 seconds
setInterval(checkAutoReturn, 30000);

// â”€â”€ Stats (7 core states) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STATS = {
  sleeping:  { bpm: [45, 55],  hype: [5, 15],   vibe: 'ğŸ’¤ zzz...' },
  idle:      { bpm: [60, 70],  hype: [25, 45],  vibe: 'ğŸ˜¶ vibing' },
  focused:   { bpm: [70, 80],  hype: [60, 80],  vibe: 'ğŸ”’ locked in' },
  happy:     { bpm: [80, 95],  hype: [75, 95],  vibe: 'ğŸ˜Š feeling good' },
  stressed:  { bpm: [95, 115], hype: [40, 60],  vibe: 'ğŸ˜° sweating' },
  texting:   { bpm: [68, 78],  hype: [50, 70],  vibe: 'ğŸ’¬ typing...' },
  chilling:  { bpm: [55, 65],  hype: [30, 50],  vibe: 'â˜• enjoying life' },
};

// â”€â”€ Alias Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const EMOTION_ALIASES = {
  excited: 'happy',
  tired: 'sleeping',
  bored: 'idle',
  curious: 'idle',
  thinking: 'focused',
  angry: 'stressed',
  inlove: 'happy',
};

function resolveEmotion(name) {
  return EMOTION_ALIASES[name] || name;
}
let displayBpm = 50;
let displayHype = 10;
let targetBpm = 50;
let targetHype = 10;

// â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let mouseX = 0;
let mouseY = 0;
let isHoveringStats = false;
let isHoveringSidebar = false;

// â”€â”€ Settings (persisted in localStorage) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const defaultSettings = { showStats: true, showTask: true, showVibe: true };
let settings = { ...defaultSettings };
try {
  const saved = localStorage.getItem('clawd-settings');
  if (saved) settings = { ...defaultSettings, ...JSON.parse(saved) };
} catch {}

function saveSettings() {
  localStorage.setItem('clawd-settings', JSON.stringify(settings));
}

canvas.addEventListener('mousemove', (e) => {
  mouseX = e.clientX / window.innerWidth;
  mouseY = e.clientY / window.innerHeight;
  isHoveringStats = mouseY > 0.7;
  isHoveringSidebar = mouseX > 0.85 && mouseY > 0.5;
});
canvas.addEventListener('mouseleave', () => {
  isHoveringStats = false;
  isHoveringSidebar = false;
});
canvas.addEventListener('click', (e) => {
  const x = e.clientX / window.innerWidth;
  const y = e.clientY / window.innerHeight;
  
  // Sidebar click detection
  if (x > 0.85 && y > 0.5) {
    const relY = (y - 0.5) / 0.5; // 0-1 within sidebar
    if (relY < 0.33) {
      settings.showStats = !settings.showStats;
    } else if (relY < 0.66) {
      settings.showVibe = !settings.showVibe;
    } else {
      settings.showTask = !settings.showTask;
    }
    saveSettings();
  }
});

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

// â”€â”€ Particle System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticle(type, x, y) {
  const p = { type, x, y, life: 1, maxLife: 60 + Math.random() * 40 };
  
  if (type === 'sparkle') {
    p.vx = (Math.random() - 0.5) * 2;
    p.vy = -Math.random() * 2 - 1;
    p.size = 3 + Math.random() * 4;
    p.rotation = Math.random() * Math.PI * 2;
  } else if (type === 'heart') {
    p.vx = (Math.random() - 0.5) * 1.5;
    p.vy = -Math.random() * 1.5 - 0.5;
    p.size = 8 + Math.random() * 6;
    p.maxLife = 80 + Math.random() * 40;
  } else if (type === 'sweat') {
    p.vx = Math.random() * 0.5;
    p.vy = Math.random() * 0.5 + 0.5;
    p.size = 4 + Math.random() * 3;
    p.maxLife = 40 + Math.random() * 20;
  } else if (type === 'zzz') {
    p.vx = 0.3 + Math.random() * 0.3;
    p.vy = -0.5 - Math.random() * 0.3;
    p.size = 10 + Math.random() * 8;
    p.maxLife = 100 + Math.random() * 50;
  }
  
  particles.push(p);
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 1 / p.maxLife;
    
    if (p.type === 'sparkle') {
      p.rotation += 0.1;
      p.vy += 0.02; // gravity
    } else if (p.type === 'heart') {
      p.vx *= 0.99;
      p.x += Math.sin(tick * 0.05 + i) * 0.3; // float side to side
    } else if (p.type === 'sweat') {
      p.vy += 0.05; // gravity
    }
    
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles(scale, cx, cy) {
  for (const p of particles) {
    const alpha = ease.outQuad(p.life);
    ctx.globalAlpha = alpha;
    
    if (p.type === 'sparkle') {
      ctx.save();
      ctx.translate(cx + p.x * scale, cy + p.y * scale);
      ctx.rotate(p.rotation);
      ctx.fillStyle = SPARKLE_COLOR;
      // 4-point star
      const s = p.size * scale * 0.15;
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        const r = i % 2 === 0 ? s : s * 0.3;
        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'heart') {
      ctx.fillStyle = HEART_COLOR;
      ctx.font = `${p.size * scale * 0.2}px sans-serif`;
      ctx.fillText('â™¥', cx + p.x * scale, cy + p.y * scale);
    } else if (p.type === 'sweat') {
      ctx.fillStyle = '#88CCFF';
      const s = p.size * scale * 0.1;
      ctx.beginPath();
      ctx.ellipse(cx + p.x * scale, cy + p.y * scale, s * 0.6, s, 0, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'zzz') {
      ctx.fillStyle = EYE_COLOR;
      ctx.font = `bold ${p.size * scale * 0.08}px monospace`;
      ctx.fillText('z', cx + p.x * scale, cy + p.y * scale);
    }
  }
  ctx.globalAlpha = 1;
}

// â”€â”€ Profile Interpolation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lerpProfile() {
  const t = 0.03;
  for (const key of ['bobSpeed', 'bobAmount', 'driftSpeed', 'driftAmount']) {
    currentProfile[key] = lerp(currentProfile[key], targetProfile[key], t);
  }
}

// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  const W = canvas.width;
  const H = canvas.height;
  const scale = Math.min(W, H) / 140;
  let cx = W / 2;
  let cy = H * 0.4;
  
  // Screen shake
  if (targetProfile.screenShake) {
    shakeX = (Math.random() - 0.5) * scale * targetProfile.screenShake * 2;
    shakeY = (Math.random() - 0.5) * scale * targetProfile.screenShake * 2;
  } else {
    shakeX *= 0.9;
    shakeY *= 0.9;
  }
  cx += shakeX;
  cy += shakeY;

  const p = currentProfile;

  // Background (single theme color)
  ctx.fillStyle = THEME_BG;
  ctx.fillRect(0, 0, W, H);

  // Bob with squash/stretch
  const bobPhase = tick * p.bobSpeed;
  const rawBob = Math.sin(bobPhase);
  const bobY = rawBob * scale * p.bobAmount;
  
  // Squash when at bottom of bob, stretch when at top
  const squashFromBob = 1 + (rawBob * 0.05 * (targetSquash - 0.9));
  currentSquash = lerp(currentSquash, targetSquash * squashFromBob, 0.1);

  // Drift
  const driftX = Math.sin(tick * p.driftSpeed) * scale * p.driftAmount
               + Math.sin(tick * p.driftSpeed * 0.4) * scale * p.driftAmount * 0.5;
  let driftY = Math.cos(tick * p.driftSpeed * 0.75) * scale * p.driftAmount * 0.5;
  
  // Look up when thinking
  if (targetProfile.lookUp) {
    driftY -= scale * 3;
  }

  // Jitter
  let jitterX = 0, jitterY = 0;
  if (targetProfile.jitter) {
    jitterX = (Math.random() - 0.5) * scale * 0.8;
    jitterY = (Math.random() - 0.5) * scale * 0.5;
  }

  // â”€â”€ Blush â”€â”€
  currentBlush = lerp(currentBlush, targetBlush, 0.05);
  if (currentBlush > 0.01) {
    const blushSize = scale * 8;
    const blushY = cy + scale * 5 + bobY;
    ctx.fillStyle = BLUSH_COLOR + (currentBlush * 0.5) + ')';
    // Left cheek
    ctx.beginPath();
    ctx.ellipse(cx - scale * 22 + driftX, blushY + driftY * 0.3, blushSize, blushSize * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    // Right cheek
    ctx.beginPath();
    ctx.ellipse(cx + scale * 22 + driftX, blushY + driftY * 0.3, blushSize, blushSize * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // â”€â”€ Eyes â”€â”€
  const eyeW = scale * 18 / currentSquash;    // Bigger eyes (EMO-style)
  const eyeMaxH = scale * 22 * currentSquash; // Taller for cuter look
  const eyeMinH = scale * 2.5;
  const eyeH = lerp(eyeMinH, eyeMaxH, openness);
  const eyeGap = scale * 22;  // Wider gap for bigger eyes
  const eyeY = cy - scale * 6 + bobY + driftY;
  const eyeX = cx + driftX + jitterX;

  // Eye positions (needed for both eyes and eyebrows)
  const leftEyeX = Math.round(eyeX - eyeGap - eyeW / 2);
  const rightEyeX = Math.round(eyeX + eyeGap - eyeW / 2);
  const eyeTop = Math.round(eyeY - eyeH / 2 + jitterY);

  if (targetProfile.heartEyes && openness > 0.15) {
    // Heart Eyes
    const heartScale = openness;
    const pxSize = scale * 2 * heartScale;
    const hRows = HEART_SHAPE.length;
    const hCols = HEART_SHAPE[0].length;
    const heartW = hCols * pxSize;
    const heartH = hRows * pxSize;

    ctx.fillStyle = HEART_COLOR;
    for (const offsetX of [-eyeGap, eyeGap]) {
      const hx = eyeX + offsetX - heartW / 2;
      const hy = eyeY - heartH / 2 + jitterY;
      for (let r = 0; r < hRows; r++) {
        for (let c = 0; c < hCols; c++) {
          if (HEART_SHAPE[r][c]) {
            ctx.fillRect(
              Math.round(hx + c * pxSize),
              Math.round(hy + r * pxSize),
              Math.ceil(pxSize),
              Math.ceil(pxSize)
            );
          }
        }
      }
    }
  } else {
    // Normal eyes
    const eyeColor = EYE_COLOR;
    ctx.fillStyle = eyeColor;
    
    ctx.fillRect(leftEyeX, eyeTop, Math.round(eyeW), Math.round(eyeH));
    ctx.fillRect(rightEyeX, eyeTop, Math.round(eyeW), Math.round(eyeH));
  }

  // â”€â”€ Eyebrows â”€â”€
  const browType = targetProfile.eyebrows || 'none';
  if (browType !== 'none') {
    const eyeColor = EYE_COLOR;
    ctx.fillStyle = eyeColor;
    const browW = scale * 10;
    const browH = scale * 2.5;
    const browY = eyeTop - scale * 6;
    
    if (browType === 'raised') {
      // Happy/surprised - raised brows (horizontal, higher)
      const raisedY = browY - scale * 2;
      ctx.fillRect(Math.round(leftEyeX - scale), Math.round(raisedY), Math.round(browW), Math.round(browH));
      ctx.fillRect(Math.round(rightEyeX - scale), Math.round(raisedY), Math.round(browW), Math.round(browH));
    } else if (browType === 'furrowed') {
      // Focused/angry - angled inward â•± â•²
      ctx.save();
      // Left brow - angled down toward center
      ctx.translate(leftEyeX + eyeW/2, browY);
      ctx.rotate(0.25);
      ctx.fillRect(-browW/2, -browH/2, browW, browH);
      ctx.restore();
      ctx.save();
      // Right brow - angled down toward center  
      ctx.translate(rightEyeX + eyeW/2, browY);
      ctx.rotate(-0.25);
      ctx.fillRect(-browW/2, -browH/2, browW, browH);
      ctx.restore();
    } else if (browType === 'worried') {
      // Stressed - angled outward (reverse of furrowed) â•² â•±
      ctx.save();
      ctx.translate(leftEyeX + eyeW/2, browY);
      ctx.rotate(-0.3);
      ctx.fillRect(-browW/2, -browH/2, browW, browH);
      ctx.restore();
      ctx.save();
      ctx.translate(rightEyeX + eyeW/2, browY);
      ctx.rotate(0.3);
      ctx.fillRect(-browW/2, -browH/2, browW, browH);
      ctx.restore();
    }
  }

  // â”€â”€ Mouth â”€â”€
  if (mouthShow > 0.02) {
    const mouthY = cy + scale * 16 + bobY + driftY * 0.3;
    const mouthX = eyeX + jitterX * 0.3;
    
    ctx.fillStyle = EYE_COLOR;
    ctx.globalAlpha = Math.min(1, mouthShow);
    
    if (currentMouthType === 'smile') {
      // Happy curved mouth (simple arc)
      const mouthW = scale * 10;
      const mouthH = scale * 4 * mouthShow;
      ctx.beginPath();
      ctx.arc(mouthX, mouthY - mouthH/2, mouthW/2, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.lineTo(mouthX - mouthW/2 + scale, mouthY);
      ctx.fill();
    } else if (currentMouthType === 'open') {
      // Excited open mouth
      const mouthW = scale * 10;
      const mouthH = scale * 8 * mouthShow;
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2),
        Math.round(mouthY - mouthH / 2),
        Math.round(mouthW),
        Math.round(mouthH)
      );
    } else if (currentMouthType === 'small-o') {
      // Curious "o" mouth
      const mouthSize = scale * 5 * mouthShow;
      ctx.beginPath();
      ctx.arc(mouthX, mouthY, mouthSize/2, 0, Math.PI * 2);
      ctx.fill();
    } else if (currentMouthType === 'worried') {
      // Wavy worried mouth
      ctx.beginPath();
      ctx.moveTo(mouthX - scale * 4, mouthY);
      ctx.quadraticCurveTo(mouthX - scale * 2, mouthY + scale * 2, mouthX, mouthY);
      ctx.quadraticCurveTo(mouthX + scale * 2, mouthY - scale * 2, mouthX + scale * 4, mouthY);
      ctx.lineWidth = scale * 1.5;
      ctx.strokeStyle = EYE_COLOR;
      ctx.stroke();
    } else if (currentMouthType === 'content') {
      // Relaxed gentle smile - like :3 or soft curve
      const mouthW = scale * 6;
      ctx.beginPath();
      ctx.arc(mouthX, mouthY, mouthW/2, 0.15 * Math.PI, 0.85 * Math.PI);
      ctx.lineWidth = scale * 1.8;
      ctx.strokeStyle = EYE_COLOR;
      ctx.stroke();
    } else if (currentMouthType === 'grr') {
      // Angry teeth
      const mouthW = scale * 12;
      const mouthH = scale * 5 * mouthShow;
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2),
        Math.round(mouthY - mouthH / 2),
        Math.round(mouthW),
        Math.round(mouthH)
      );
      // White line for teeth
      ctx.fillStyle = '#fff';
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2 + scale),
        Math.round(mouthY - scale * 0.5),
        Math.round(mouthW - scale * 2),
        Math.round(scale)
      );
    } else {
      // Default neutral mouth
      const mouthW = scale * 8;
      const mouthH = scale * 4 * mouthShow;
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2),
        Math.round(mouthY - mouthH / 2),
        Math.round(mouthW),
        Math.round(mouthH)
      );
    }
    ctx.globalAlpha = 1;
  }

  // â”€â”€ Anger Mark â”€â”€
  if (targetProfile.showAngerMark) {
    const markX = eyeX + scale * 28;
    const markY = cy - scale * 18 + bobY;
    ctx.strokeStyle = '#CC3333';
    ctx.lineWidth = scale * 1.2;
    ctx.beginPath();
    // Cross pattern (anger vein)
    ctx.moveTo(markX - scale * 3, markY - scale * 3);
    ctx.lineTo(markX + scale * 3, markY + scale * 3);
    ctx.moveTo(markX + scale * 3, markY - scale * 3);
    ctx.lineTo(markX - scale * 3, markY + scale * 3);
    ctx.moveTo(markX, markY - scale * 4);
    ctx.lineTo(markX, markY + scale * 4);
    ctx.moveTo(markX - scale * 4, markY);
    ctx.lineTo(markX + scale * 4, markY);
    ctx.stroke();
  }

  // â”€â”€ Particles â”€â”€
  drawParticles(scale, cx, cy);

  // â”€â”€ Stats Panel (bigger, cleaner) â”€â”€
  const fontSize = Math.max(18, Math.round(scale * 4));
  const smallFont = Math.max(14, Math.round(scale * 3));
  const statsY = H * 0.82;
  const baseAlpha = isHoveringStats ? 1.0 : 0.65;

  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';

  // BPM & Hype (bigger!)
  if (settings.showStats) {
    ctx.font = `bold ${fontSize}px monospace`;
    ctx.globalAlpha = baseAlpha;
    const bpmStr = `â™¥ ${Math.round(displayBpm)} bpm`;
    const hypeStr = `âš¡ ${Math.round(displayHype)}%`;
    const gap = scale * 28;
    ctx.fillText(bpmStr, cx - gap, statsY);
    ctx.fillText(hypeStr, cx + gap, statsY);
  }

  // Vibe status
  const st = STATS[emotion] || STATS.idle;
  if (settings.showVibe) {
    ctx.font = `${smallFont}px monospace`;
    ctx.globalAlpha = baseAlpha * 0.9;
    ctx.fillText(st.vibe, cx, statsY + fontSize * 1.4);
  }

  // Task
  if (settings.showTask) {
    ctx.font = `${Math.round(smallFont * 0.9)}px monospace`;
    ctx.globalAlpha = baseAlpha * 0.75;
    const displayTask = task.length > 50 ? task.slice(0, 47) + '...' : task;
    const taskY = settings.showVibe ? statsY + fontSize * 2.5 : statsY + fontSize * 1.4;
    ctx.fillText(displayTask, cx, taskY);
  }

  // â”€â”€ Settings Sidebar (on hover) â”€â”€
  if (isHoveringSidebar || isHoveringStats) {
    const sbW = W * 0.12;
    const sbH = H * 0.35;
    const sbX = W - sbW - 10;
    const sbY = H * 0.55;
    
    // Sidebar background
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.beginPath();
    ctx.roundRect(sbX, sbY, sbW, sbH, 8);
    ctx.fill();
    
    // Title
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.9;
    ctx.font = `bold ${Math.round(scale * 2.5)}px monospace`;
    ctx.textAlign = 'left';
    ctx.fillText('âš™ï¸ Settings', sbX + 10, sbY + 25);
    
    // Toggle items
    ctx.font = `${Math.round(scale * 2)}px monospace`;
    const items = [
      { key: 'showStats', label: 'Stats (BPM/Hype)' },
      { key: 'showVibe', label: 'Mood Status' },
      { key: 'showTask', label: 'Task Text' },
    ];
    
    items.forEach((item, i) => {
      const y = sbY + 55 + i * 30;
      const checked = settings[item.key];
      ctx.globalAlpha = checked ? 0.95 : 0.5;
      ctx.fillText(`${checked ? 'â˜‘' : 'â˜'} ${item.label}`, sbX + 10, y);
    });
  }

  ctx.globalAlpha = 1;
  ctx.textAlign = 'start';
}

// â”€â”€ Animation Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateAnimation() {
  const p = targetProfile;

  // Smooth lerp
  openness = lerp(openness, targetOpenness, 0.06);
  mouthShow = lerp(mouthShow, targetMouth, 0.08);
  targetSquash = p.squash || 1.0;
  targetBlush = p.blush || 0;

  lerpProfile();
  updateParticles();

  // Spawn particles
  if (targetProfile.showSparkles && Math.random() < 0.08) {
    spawnParticle('sparkle', (Math.random() - 0.5) * 60, -20 - Math.random() * 20);
  }
  if (targetProfile.showHearts && Math.random() < 0.05) {
    const side = Math.random() < 0.5 ? -1 : 1;
    spawnParticle('heart', side * (25 + Math.random() * 10), -10);
  }
  if (targetProfile.showSweat && Math.random() < 0.04) {
    spawnParticle('sweat', 30 + Math.random() * 5, -15);
  }
  if (targetProfile.showZzz && Math.random() < 0.02) {
    spawnParticle('zzz', 25, -15);
  }

  nextEvent--;
  if (nextEvent <= 0) {
    if (currentPhase === 'idle') {
      const r = Math.random();
      if (r < p.blinkRate) {
        currentPhase = 'blinking';
        targetOpenness = 0;
        nextEvent = 8 + Math.random() * 4;
      } else if (r < p.blinkRate + p.squintRate) {
        currentPhase = 'squinting';
        targetOpenness = p.eyeOpen * 0.15;
        nextEvent = 25 + Math.random() * 40;
      } else if (r < p.blinkRate + p.squintRate + 0.2) {
        targetMouth = Math.random() < p.mouthChance ? 1 : 0;
        if (targetMouth > 0) currentMouthType = p.mouthType || 'neutral';
        scheduleNext();
      } else {
        scheduleNext();
      }
    } else if (currentPhase === 'blinking') {
      targetOpenness = p.eyeOpen;
      currentPhase = 'idle';
      scheduleNext();
    } else if (currentPhase === 'squinting') {
      targetOpenness = p.eyeOpen;
      if (Math.random() < 0.4) {
        targetMouth = Math.random() < p.mouthChance ? 1 : 0;
      }
      currentPhase = 'idle';
      scheduleNext();
    }
  }

  if (openness < 0.2 && targetMouth > 0.5) {
    targetMouth = 0;
  }

  // Stats
  const st = STATS[emotion] || STATS.idle;
  if (tick % 30 === 0) {
    targetBpm = st.bpm[0] + Math.random() * (st.bpm[1] - st.bpm[0]);
    targetHype = st.hype[0] + Math.random() * (st.hype[1] - st.hype[0]);
  }
  displayBpm = lerp(displayBpm, targetBpm, 0.015);
  displayHype = lerp(displayHype, targetHype, 0.025);
}

function scheduleNext() {
  const [min, max] = targetProfile.eventDelay;
  nextEvent = min + Math.random() * (max - min);
}

// â”€â”€ Main Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  tick++;
  updateAnimation();
  draw();
  requestAnimationFrame(loop);
}
loop();

// â”€â”€ Tab Title â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateTitle() {
  const resolved = resolveEmotion(emotion);
  const st = STATS[resolved] || STATS.idle;
  const vibe = st.vibe.replace(/^[\p{Emoji}\uFE0F\u200D]+\s*/u, '');
  document.title = `clawd: ${vibe}`;
}

// â”€â”€ Emotion Change â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setEmotion(newEmotion) {
  // Resolve aliases to core emotions
  const resolved = resolveEmotion(newEmotion);
  
  if (PROFILES[resolved]) {
    emotion = resolved;
    targetProfile = PROFILES[resolved];
    targetOpenness = targetProfile.eyeOpen;
    targetMouth = Math.random() < targetProfile.mouthChance ? 1 : 0;
    currentMouthType = targetProfile.mouthType || 'neutral';
    
    const st = STATS[resolved] || STATS.idle;
    targetBpm = st.bpm[0] + Math.random() * (st.bpm[1] - st.bpm[0]);
    targetHype = st.hype[0] + Math.random() * (st.hype[1] - st.hype[0]);
    updateTitle();
    
    // Reset signal timer (for auto-return to idle)
    lastSignalTime = Date.now();
    
    // Clear/start idle activities
    if (idleActivityTimer) clearTimeout(idleActivityTimer);
    if (resolved === 'idle') {
      scheduleIdleActivity();
    }
    
    // Burst particles on emotion change
    if (resolved === 'happy') {
      for (let i = 0; i < 5; i++) {
        setTimeout(() => spawnParticle('sparkle', (Math.random() - 0.5) * 50, -15 - Math.random() * 15), i * 50);
      }
    }
  }
}

// â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
const ws = new WebSocket(`${protocol}//${location.host}`);

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  if (msg.type === 'statusUpdate') {
    setEmotion(msg.data.emotion);
    task = msg.data.task;
    energy = msg.data.energy;
  }
};
</script>
</body>
</html>
