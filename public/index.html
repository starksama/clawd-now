<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>clawd: zzz...</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// â”€â”€ Easing Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ease = {
  linear: t => t,
  inQuad: t => t * t,
  outQuad: t => t * (2 - t),
  inOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  inCubic: t => t * t * t,
  outCubic: t => (--t) * t * t + 1,
  inOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  inElastic: t => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * ((2 * Math.PI) / 3)),
  outElastic: t => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1,
  outBounce: t => {
    const n1 = 7.5625, d1 = 2.75;
    if (t < 1 / d1) return n1 * t * t;
    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  },
};

// â”€â”€ Emotion Profiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PROFILES = {
  sleeping: {
    bg: '#E8A090',
    eyeOpen: 0.12,
    mouthChance: 0.05,
    mouthType: 'neutral',
    bobSpeed: 0.008,
    bobAmount: 1.5,
    driftSpeed: 0.002,
    driftAmount: 1,
    blinkRate: 0.005,
    squintRate: 0.01,
    eventDelay: [200, 400],
    showZzz: true,
    eyeShine: false,
    blush: 0,
    squash: 1.0,
  },
  idle: {
    bg: '#E8937C',
    eyeOpen: 1.0,
    mouthChance: 0.4,
    mouthType: 'neutral',
    bobSpeed: 0.015,
    bobAmount: 2.5,
    driftSpeed: 0.008,
    driftAmount: 3,
    blinkRate: 0.25,
    squintRate: 0.15,
    eventDelay: [80, 200],
    showZzz: false,
    eyeShine: true,
    blush: 0,
    squash: 1.0,
  },
  focused: {
    bg: '#E08D76',
    eyeOpen: 0.35,
    mouthChance: 0.08,
    mouthType: 'neutral',
    bobSpeed: 0.025,
    bobAmount: 1.2,
    driftSpeed: 0.003,
    driftAmount: 0.8,
    blinkRate: 0.08,
    squintRate: 0.03,
    eventDelay: [200, 400],
    showZzz: false,
    eyeShine: true,
    blush: 0,
    squash: 1.0,
  },
  happy: {
    bg: '#E89880',
    eyeOpen: 0.85,
    mouthChance: 0.9,
    mouthType: 'smile',
    bobSpeed: 0.022,
    bobAmount: 4,
    driftSpeed: 0.012,
    driftAmount: 4,
    blinkRate: 0.3,
    squintRate: 0.1,
    eventDelay: [60, 150],
    showZzz: false,
    eyeShine: true,
    blush: 0.4,
    squash: 1.15,
    showSparkles: true,
  },
  excited: {
    bg: '#E58A70',
    eyeOpen: 1.0,
    mouthChance: 0.95,
    mouthType: 'open',
    bobSpeed: 0.035,
    bobAmount: 6,
    driftSpeed: 0.018,
    driftAmount: 5,
    blinkRate: 0.35,
    squintRate: 0.05,
    eventDelay: [40, 100],
    showZzz: false,
    eyeShine: true,
    blush: 0.3,
    squash: 1.25,
    showSparkles: true,
    screenShake: 0.3,
  },
  stressed: {
    bg: '#E08870',
    eyeOpen: 0.7,
    mouthChance: 0.15,
    mouthType: 'worried',
    bobSpeed: 0.02,
    bobAmount: 1.5,
    driftSpeed: 0.015,
    driftAmount: 2,
    blinkRate: 0.4,
    squintRate: 0.2,
    eventDelay: [50, 120],
    showZzz: false,
    jitter: true,
    eyeShine: false,
    blush: 0,
    squash: 0.95,
    showSweat: true,
  },
  tired: {
    bg: '#E0A090',
    eyeOpen: 0.4,
    mouthChance: 0.2,
    mouthType: 'neutral',
    bobSpeed: 0.01,
    bobAmount: 2,
    driftSpeed: 0.004,
    driftAmount: 2,
    blinkRate: 0.15,
    squintRate: 0.3,
    eventDelay: [120, 300],
    showZzz: false,
    eyeShine: false,
    blush: 0,
    squash: 0.9,
  },
  bored: {
    bg: '#D8A090',
    eyeOpen: 0.5,
    mouthChance: 0.3,
    mouthType: 'neutral',
    bobSpeed: 0.006,
    bobAmount: 1,
    driftSpeed: 0.015,
    driftAmount: 5,
    blinkRate: 0.2,
    squintRate: 0.25,
    eventDelay: [100, 250],
    showZzz: false,
    eyeShine: false,
    blush: 0,
    squash: 1.0,
  },
  curious: {
    bg: '#E89580',
    eyeOpen: 1.0,
    mouthChance: 0.5,
    mouthType: 'small-o',
    bobSpeed: 0.02,
    bobAmount: 3,
    driftSpeed: 0.02,
    driftAmount: 6,
    blinkRate: 0.3,
    squintRate: 0.05,
    eventDelay: [50, 120],
    showZzz: false,
    eyeShine: true,
    blush: 0.1,
    squash: 1.05,
  },
  thinking: {
    bg: '#D4A08E',
    eyeOpen: 0.45,
    mouthChance: 0.05,
    mouthType: 'hmm',
    bobSpeed: 0.012,
    bobAmount: 1.8,
    driftSpeed: 0.005,
    driftAmount: 2,
    blinkRate: 0.1,
    squintRate: 0.2,
    eventDelay: [150, 350],
    showZzz: false,
    eyeShine: false,
    blush: 0,
    squash: 1.0,
    lookUp: true,
  },
  angry: {
    bg: '#C85A5A',
    eyeOpen: 0.3,
    mouthChance: 0.7,
    mouthType: 'grr',
    bobSpeed: 0.04,
    bobAmount: 3,
    driftSpeed: 0.002,
    driftAmount: 0.5,
    blinkRate: 0.05,
    squintRate: 0.4,
    eventDelay: [30, 80],
    showZzz: false,
    jitter: true,
    eyeShine: false,
    blush: 0.5,
    squash: 0.9,
    screenShake: 0.5,
    showAngerMark: true,
  },
  texting: {
    bg: '#E0926E',
    eyeOpen: 0.8,
    mouthChance: 0.6,
    mouthType: 'neutral',
    bobSpeed: 0.03,
    bobAmount: 2,
    driftSpeed: 0.004,
    driftAmount: 1,
    blinkRate: 0.25,
    squintRate: 0.08,
    eventDelay: [40, 100],
    showZzz: false,
    eyeShine: true,
    blush: 0,
    squash: 1.0,
  },
  inlove: {
    bg: '#E8889C',
    eyeOpen: 1.0,
    mouthChance: 0.85,
    mouthType: 'smile',
    bobSpeed: 0.018,
    bobAmount: 3.5,
    driftSpeed: 0.006,
    driftAmount: 2,
    blinkRate: 0.12,
    squintRate: 0.03,
    eventDelay: [80, 200],
    showZzz: false,
    showHearts: true,
    heartEyes: true,
    eyeShine: false,
    blush: 0.7,
    squash: 1.1,
  },
};

const EYE_COLOR = '#3D2817';
const HEART_COLOR = '#CC2244';
const BLUSH_COLOR = 'rgba(255, 120, 140, ';
const SPARKLE_COLOR = '#FFE066';

// Heart pixel art (7x8)
const HEART_SHAPE = [
  [0,1,1,0,1,1,0],
  [1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1],
  [1,1,1,1,1,1,1],
  [0,1,1,1,1,1,0],
  [0,1,1,1,1,1,0],
  [0,0,1,1,1,0,0],
  [0,0,0,1,0,0,0],
];

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let emotion = 'sleeping';
let task = 'Resting peacefully...';
let energy = 100;
let tick = 0;

let openness = 0.12;
let targetOpenness = 0.12;
let mouthShow = 0;
let targetMouth = 0;
let currentMouthType = 'neutral';

let nextEvent = 100;
let currentPhase = 'idle';

let currentProfile = { ...PROFILES.sleeping };
let targetProfile = PROFILES.sleeping;

// Particles
let particles = [];

// Smooth values for squash/stretch
let currentSquash = 1.0;
let targetSquash = 1.0;

// Screen shake
let shakeX = 0;
let shakeY = 0;

// Blush alpha
let currentBlush = 0;
let targetBlush = 0;

// â”€â”€ Stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STATS = {
  sleeping:  { bpm: [45, 55],  hype: [5, 15],   vibe: 'ðŸ’¤ zzz...' },
  idle:      { bpm: [60, 70],  hype: [20, 40],  vibe: 'ðŸ˜¶ vibing' },
  focused:   { bpm: [72, 82],  hype: [50, 70],  vibe: 'ðŸ”’ locked in' },
  happy:     { bpm: [75, 85],  hype: [60, 80],  vibe: 'ðŸ˜Š feeling good' },
  excited:   { bpm: [95, 120], hype: [85, 100], vibe: 'ðŸš€ LFG!!' },
  stressed:  { bpm: [88, 105], hype: [30, 50],  vibe: 'ðŸ˜° sweating' },
  tired:     { bpm: [50, 60],  hype: [10, 25],  vibe: 'ðŸ¥± need coffee' },
  bored:     { bpm: [55, 65],  hype: [5, 20],   vibe: 'ðŸ˜‘ meh...' },
  curious:   { bpm: [70, 85],  hype: [55, 75],  vibe: 'ðŸ‘€ interesting...' },
  angry:     { bpm: [100, 130], hype: [70, 95],  vibe: 'ðŸ˜¤ don\'t test me' },
  thinking:  { bpm: [65, 78],  hype: [40, 60],  vibe: 'ðŸ§  processing...' },
  texting:   { bpm: [72, 85],  hype: [45, 65],  vibe: 'ðŸ’¬ typing...' },
  inlove:    { bpm: [90, 115], hype: [80, 100], vibe: 'ðŸ˜ in love!!' },
};
let displayBpm = 50;
let displayHype = 10;
let targetBpm = 50;
let targetHype = 10;

// â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let mouseY = 0;
let isHoveringStats = false;

canvas.addEventListener('mousemove', (e) => {
  mouseY = e.clientY / window.innerHeight;
  isHoveringStats = mouseY > 0.7;
});
canvas.addEventListener('mouseleave', () => isHoveringStats = false);

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

// â”€â”€ Particle System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticle(type, x, y) {
  const p = { type, x, y, life: 1, maxLife: 60 + Math.random() * 40 };
  
  if (type === 'sparkle') {
    p.vx = (Math.random() - 0.5) * 2;
    p.vy = -Math.random() * 2 - 1;
    p.size = 3 + Math.random() * 4;
    p.rotation = Math.random() * Math.PI * 2;
  } else if (type === 'heart') {
    p.vx = (Math.random() - 0.5) * 1.5;
    p.vy = -Math.random() * 1.5 - 0.5;
    p.size = 8 + Math.random() * 6;
    p.maxLife = 80 + Math.random() * 40;
  } else if (type === 'sweat') {
    p.vx = Math.random() * 0.5;
    p.vy = Math.random() * 0.5 + 0.5;
    p.size = 4 + Math.random() * 3;
    p.maxLife = 40 + Math.random() * 20;
  } else if (type === 'zzz') {
    p.vx = 0.3 + Math.random() * 0.3;
    p.vy = -0.5 - Math.random() * 0.3;
    p.size = 10 + Math.random() * 8;
    p.maxLife = 100 + Math.random() * 50;
  }
  
  particles.push(p);
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 1 / p.maxLife;
    
    if (p.type === 'sparkle') {
      p.rotation += 0.1;
      p.vy += 0.02; // gravity
    } else if (p.type === 'heart') {
      p.vx *= 0.99;
      p.x += Math.sin(tick * 0.05 + i) * 0.3; // float side to side
    } else if (p.type === 'sweat') {
      p.vy += 0.05; // gravity
    }
    
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles(scale, cx, cy) {
  for (const p of particles) {
    const alpha = ease.outQuad(p.life);
    ctx.globalAlpha = alpha;
    
    if (p.type === 'sparkle') {
      ctx.save();
      ctx.translate(cx + p.x * scale, cy + p.y * scale);
      ctx.rotate(p.rotation);
      ctx.fillStyle = SPARKLE_COLOR;
      // 4-point star
      const s = p.size * scale * 0.15;
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2;
        const r = i % 2 === 0 ? s : s * 0.3;
        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else if (p.type === 'heart') {
      ctx.fillStyle = HEART_COLOR;
      ctx.font = `${p.size * scale * 0.2}px sans-serif`;
      ctx.fillText('â™¥', cx + p.x * scale, cy + p.y * scale);
    } else if (p.type === 'sweat') {
      ctx.fillStyle = '#88CCFF';
      const s = p.size * scale * 0.1;
      ctx.beginPath();
      ctx.ellipse(cx + p.x * scale, cy + p.y * scale, s * 0.6, s, 0, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'zzz') {
      ctx.fillStyle = EYE_COLOR;
      ctx.font = `bold ${p.size * scale * 0.08}px monospace`;
      ctx.fillText('z', cx + p.x * scale, cy + p.y * scale);
    }
  }
  ctx.globalAlpha = 1;
}

// â”€â”€ Profile Interpolation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lerpProfile() {
  const t = 0.03;
  for (const key of ['bobSpeed', 'bobAmount', 'driftSpeed', 'driftAmount']) {
    currentProfile[key] = lerp(currentProfile[key], targetProfile[key], t);
  }
}

// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  const W = canvas.width;
  const H = canvas.height;
  const scale = Math.min(W, H) / 140;
  let cx = W / 2;
  let cy = H * 0.4;
  
  // Screen shake
  if (targetProfile.screenShake) {
    shakeX = (Math.random() - 0.5) * scale * targetProfile.screenShake * 2;
    shakeY = (Math.random() - 0.5) * scale * targetProfile.screenShake * 2;
  } else {
    shakeX *= 0.9;
    shakeY *= 0.9;
  }
  cx += shakeX;
  cy += shakeY;

  const p = currentProfile;

  // Background
  ctx.fillStyle = targetProfile.bg;
  ctx.fillRect(0, 0, W, H);

  // Bob with squash/stretch
  const bobPhase = tick * p.bobSpeed;
  const rawBob = Math.sin(bobPhase);
  const bobY = rawBob * scale * p.bobAmount;
  
  // Squash when at bottom of bob, stretch when at top
  const squashFromBob = 1 + (rawBob * 0.05 * (targetSquash - 0.9));
  currentSquash = lerp(currentSquash, targetSquash * squashFromBob, 0.1);

  // Drift
  const driftX = Math.sin(tick * p.driftSpeed) * scale * p.driftAmount
               + Math.sin(tick * p.driftSpeed * 0.4) * scale * p.driftAmount * 0.5;
  let driftY = Math.cos(tick * p.driftSpeed * 0.75) * scale * p.driftAmount * 0.5;
  
  // Look up when thinking
  if (targetProfile.lookUp) {
    driftY -= scale * 3;
  }

  // Jitter
  let jitterX = 0, jitterY = 0;
  if (targetProfile.jitter) {
    jitterX = (Math.random() - 0.5) * scale * 0.8;
    jitterY = (Math.random() - 0.5) * scale * 0.5;
  }

  // â”€â”€ Blush â”€â”€
  currentBlush = lerp(currentBlush, targetBlush, 0.05);
  if (currentBlush > 0.01) {
    const blushSize = scale * 8;
    const blushY = cy + scale * 5 + bobY;
    ctx.fillStyle = BLUSH_COLOR + (currentBlush * 0.5) + ')';
    // Left cheek
    ctx.beginPath();
    ctx.ellipse(cx - scale * 22 + driftX, blushY + driftY * 0.3, blushSize, blushSize * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    // Right cheek
    ctx.beginPath();
    ctx.ellipse(cx + scale * 22 + driftX, blushY + driftY * 0.3, blushSize, blushSize * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // â”€â”€ Eyes â”€â”€
  const eyeW = scale * 14 / currentSquash;
  const eyeMaxH = scale * 16 * currentSquash;
  const eyeMinH = scale * 2.5;
  const eyeH = lerp(eyeMinH, eyeMaxH, openness);
  const eyeGap = scale * 18;
  const eyeY = cy - scale * 6 + bobY + driftY;
  const eyeX = cx + driftX + jitterX;

  if (targetProfile.heartEyes && openness > 0.15) {
    // Heart Eyes
    const heartScale = openness;
    const pxSize = scale * 2 * heartScale;
    const hRows = HEART_SHAPE.length;
    const hCols = HEART_SHAPE[0].length;
    const heartW = hCols * pxSize;
    const heartH = hRows * pxSize;

    ctx.fillStyle = HEART_COLOR;
    for (const offsetX of [-eyeGap, eyeGap]) {
      const hx = eyeX + offsetX - heartW / 2;
      const hy = eyeY - heartH / 2 + jitterY;
      for (let r = 0; r < hRows; r++) {
        for (let c = 0; c < hCols; c++) {
          if (HEART_SHAPE[r][c]) {
            ctx.fillRect(
              Math.round(hx + c * pxSize),
              Math.round(hy + r * pxSize),
              Math.ceil(pxSize),
              Math.ceil(pxSize)
            );
          }
        }
      }
    }
  } else {
    // Normal eyes
    ctx.fillStyle = EYE_COLOR;
    const leftEyeX = Math.round(eyeX - eyeGap - eyeW / 2);
    const rightEyeX = Math.round(eyeX + eyeGap - eyeW / 2);
    const eyeTop = Math.round(eyeY - eyeH / 2 + jitterY);
    
    ctx.fillRect(leftEyeX, eyeTop, Math.round(eyeW), Math.round(eyeH));
    ctx.fillRect(rightEyeX, eyeTop, Math.round(eyeW), Math.round(eyeH));
    
    // Eye shine (when eyes are open enough)
    if (targetProfile.eyeShine && openness > 0.4) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      const shineSize = scale * 3;
      const shineOffsetX = scale * 3;
      const shineOffsetY = -scale * 2;
      ctx.fillRect(
        leftEyeX + shineOffsetX,
        eyeTop + shineOffsetY + eyeH * 0.2,
        shineSize, shineSize
      );
      ctx.fillRect(
        rightEyeX + shineOffsetX,
        eyeTop + shineOffsetY + eyeH * 0.2,
        shineSize, shineSize
      );
    }
  }

  // â”€â”€ Mouth â”€â”€
  if (mouthShow > 0.02) {
    const mouthY = cy + scale * 16 + bobY + driftY * 0.3;
    const mouthX = eyeX + jitterX * 0.3;
    
    ctx.fillStyle = EYE_COLOR;
    ctx.globalAlpha = Math.min(1, mouthShow);
    
    if (currentMouthType === 'smile') {
      // Happy curved mouth (simple arc)
      const mouthW = scale * 10;
      const mouthH = scale * 4 * mouthShow;
      ctx.beginPath();
      ctx.arc(mouthX, mouthY - mouthH/2, mouthW/2, 0.1 * Math.PI, 0.9 * Math.PI);
      ctx.lineTo(mouthX - mouthW/2 + scale, mouthY);
      ctx.fill();
    } else if (currentMouthType === 'open') {
      // Excited open mouth
      const mouthW = scale * 10;
      const mouthH = scale * 8 * mouthShow;
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2),
        Math.round(mouthY - mouthH / 2),
        Math.round(mouthW),
        Math.round(mouthH)
      );
    } else if (currentMouthType === 'small-o') {
      // Curious "o" mouth
      const mouthSize = scale * 5 * mouthShow;
      ctx.beginPath();
      ctx.arc(mouthX, mouthY, mouthSize/2, 0, Math.PI * 2);
      ctx.fill();
    } else if (currentMouthType === 'worried') {
      // Wavy worried mouth
      ctx.beginPath();
      ctx.moveTo(mouthX - scale * 4, mouthY);
      ctx.quadraticCurveTo(mouthX - scale * 2, mouthY + scale * 2, mouthX, mouthY);
      ctx.quadraticCurveTo(mouthX + scale * 2, mouthY - scale * 2, mouthX + scale * 4, mouthY);
      ctx.lineWidth = scale * 1.5;
      ctx.strokeStyle = EYE_COLOR;
      ctx.stroke();
    } else if (currentMouthType === 'grr') {
      // Angry teeth
      const mouthW = scale * 12;
      const mouthH = scale * 5 * mouthShow;
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2),
        Math.round(mouthY - mouthH / 2),
        Math.round(mouthW),
        Math.round(mouthH)
      );
      // White line for teeth
      ctx.fillStyle = '#fff';
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2 + scale),
        Math.round(mouthY - scale * 0.5),
        Math.round(mouthW - scale * 2),
        Math.round(scale)
      );
    } else {
      // Default neutral mouth
      const mouthW = scale * 8;
      const mouthH = scale * 4 * mouthShow;
      ctx.fillRect(
        Math.round(mouthX - mouthW / 2),
        Math.round(mouthY - mouthH / 2),
        Math.round(mouthW),
        Math.round(mouthH)
      );
    }
    ctx.globalAlpha = 1;
  }

  // â”€â”€ Anger Mark â”€â”€
  if (targetProfile.showAngerMark) {
    const markX = eyeX + scale * 28;
    const markY = cy - scale * 18 + bobY;
    ctx.strokeStyle = '#CC3333';
    ctx.lineWidth = scale * 1.2;
    ctx.beginPath();
    // Cross pattern (anger vein)
    ctx.moveTo(markX - scale * 3, markY - scale * 3);
    ctx.lineTo(markX + scale * 3, markY + scale * 3);
    ctx.moveTo(markX + scale * 3, markY - scale * 3);
    ctx.lineTo(markX - scale * 3, markY + scale * 3);
    ctx.moveTo(markX, markY - scale * 4);
    ctx.lineTo(markX, markY + scale * 4);
    ctx.moveTo(markX - scale * 4, markY);
    ctx.lineTo(markX + scale * 4, markY);
    ctx.stroke();
  }

  // â”€â”€ Particles â”€â”€
  drawParticles(scale, cx, cy);

  // â”€â”€ Stats Panel â”€â”€
  const fontSize = Math.max(13, Math.round(scale * 2.8));
  const smallFont = Math.max(11, Math.round(scale * 2.3));
  const statsY = H * 0.83;
  const statsAlpha = isHoveringStats ? 1.0 : 0.7;
  const vibeAlpha = isHoveringStats ? 0.95 : 0.6;
  const taskAlpha = isHoveringStats ? 0.9 : 0.5;

  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';

  ctx.font = `bold ${fontSize}px monospace`;
  ctx.globalAlpha = statsAlpha;
  const bpmStr = `â™¥ ${Math.round(displayBpm)} bpm`;
  const hypeStr = `âš¡ ${Math.round(displayHype)}%`;
  const gap = scale * 22;
  ctx.fillText(bpmStr, cx - gap, statsY);
  ctx.fillText(hypeStr, cx + gap, statsY);

  const st = STATS[emotion] || STATS.idle;
  ctx.font = `${smallFont}px monospace`;
  ctx.globalAlpha = vibeAlpha;
  ctx.fillText(st.vibe, cx, statsY + fontSize * 1.5);

  ctx.globalAlpha = taskAlpha;
  const displayTask = task.length > 50 ? task.slice(0, 47) + '...' : task;
  ctx.fillText(displayTask, cx, statsY + fontSize * 2.8);

  ctx.globalAlpha = 1;
  ctx.textAlign = 'start';
}

// â”€â”€ Animation Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateAnimation() {
  const p = targetProfile;

  // Smooth lerp
  openness = lerp(openness, targetOpenness, 0.06);
  mouthShow = lerp(mouthShow, targetMouth, 0.08);
  targetSquash = p.squash || 1.0;
  targetBlush = p.blush || 0;

  lerpProfile();
  updateParticles();

  // Spawn particles
  if (targetProfile.showSparkles && Math.random() < 0.08) {
    spawnParticle('sparkle', (Math.random() - 0.5) * 60, -20 - Math.random() * 20);
  }
  if (targetProfile.showHearts && Math.random() < 0.05) {
    const side = Math.random() < 0.5 ? -1 : 1;
    spawnParticle('heart', side * (25 + Math.random() * 10), -10);
  }
  if (targetProfile.showSweat && Math.random() < 0.04) {
    spawnParticle('sweat', 30 + Math.random() * 5, -15);
  }
  if (targetProfile.showZzz && Math.random() < 0.02) {
    spawnParticle('zzz', 25, -15);
  }

  nextEvent--;
  if (nextEvent <= 0) {
    if (currentPhase === 'idle') {
      const r = Math.random();
      if (r < p.blinkRate) {
        currentPhase = 'blinking';
        targetOpenness = 0;
        nextEvent = 8 + Math.random() * 4;
      } else if (r < p.blinkRate + p.squintRate) {
        currentPhase = 'squinting';
        targetOpenness = p.eyeOpen * 0.15;
        nextEvent = 25 + Math.random() * 40;
      } else if (r < p.blinkRate + p.squintRate + 0.2) {
        targetMouth = Math.random() < p.mouthChance ? 1 : 0;
        if (targetMouth > 0) currentMouthType = p.mouthType || 'neutral';
        scheduleNext();
      } else {
        scheduleNext();
      }
    } else if (currentPhase === 'blinking') {
      targetOpenness = p.eyeOpen;
      currentPhase = 'idle';
      scheduleNext();
    } else if (currentPhase === 'squinting') {
      targetOpenness = p.eyeOpen;
      if (Math.random() < 0.4) {
        targetMouth = Math.random() < p.mouthChance ? 1 : 0;
      }
      currentPhase = 'idle';
      scheduleNext();
    }
  }

  if (openness < 0.2 && targetMouth > 0.5) {
    targetMouth = 0;
  }

  // Stats
  const st = STATS[emotion] || STATS.idle;
  if (tick % 30 === 0) {
    targetBpm = st.bpm[0] + Math.random() * (st.bpm[1] - st.bpm[0]);
    targetHype = st.hype[0] + Math.random() * (st.hype[1] - st.hype[0]);
  }
  displayBpm = lerp(displayBpm, targetBpm, 0.015);
  displayHype = lerp(displayHype, targetHype, 0.025);
}

function scheduleNext() {
  const [min, max] = targetProfile.eventDelay;
  nextEvent = min + Math.random() * (max - min);
}

// â”€â”€ Main Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  tick++;
  updateAnimation();
  draw();
  requestAnimationFrame(loop);
}
loop();

// â”€â”€ Tab Title â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateTitle() {
  const st = STATS[emotion] || STATS.idle;
  const vibe = st.vibe.replace(/^[\p{Emoji}\uFE0F\u200D]+\s*/u, '');
  document.title = `clawd: ${vibe}`;
}

// â”€â”€ Emotion Change â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setEmotion(newEmotion) {
  if (PROFILES[newEmotion]) {
    emotion = newEmotion;
    targetProfile = PROFILES[newEmotion];
    targetOpenness = targetProfile.eyeOpen;
    targetMouth = Math.random() < targetProfile.mouthChance ? 1 : 0;
    currentMouthType = targetProfile.mouthType || 'neutral';
    
    const st = STATS[newEmotion] || STATS.idle;
    targetBpm = st.bpm[0] + Math.random() * (st.bpm[1] - st.bpm[0]);
    targetHype = st.hype[0] + Math.random() * (st.hype[1] - st.hype[0]);
    updateTitle();
    
    // Burst particles on emotion change
    if (newEmotion === 'happy' || newEmotion === 'excited') {
      for (let i = 0; i < 5; i++) {
        setTimeout(() => spawnParticle('sparkle', (Math.random() - 0.5) * 50, -15 - Math.random() * 15), i * 50);
      }
    }
    if (newEmotion === 'inlove') {
      for (let i = 0; i < 4; i++) {
        const side = i % 2 === 0 ? -1 : 1;
        setTimeout(() => spawnParticle('heart', side * (20 + Math.random() * 15), -10), i * 80);
      }
    }
  }
}

// â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
const ws = new WebSocket(`${protocol}//${location.host}`);

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  if (msg.type === 'statusUpdate') {
    setEmotion(msg.data.emotion);
    task = msg.data.task;
    energy = msg.data.energy;
  }
};
</script>
</body>
</html>
