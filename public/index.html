<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Stark</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const COLORS = {
  sleeping: '#E8C9C0',
  focused:  '#E8937C',
  happy:    '#F0A896',
  excited:  '#E8754A',
  stressed: '#D97546',
  tired:    '#D9B5A8',
};
const EYE_COLOR = '#3D2817';
const PIXEL = 6; // base pixel size, scales with screen

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let emotion = 'sleeping';
let task = 'Resting peacefully...';
let energy = 100;
let tick = 0;
let blinkTimer = 0;
let blinkProgress = 0; // 0 = open, 1 = closed
let blinkDir = 0; // 0 = idle, 1 = closing, -1 = opening
let nextBlink = randomBlink();
let particles = [];
let bobPhase = 0;
let mouthVisible = true;
let mouthTimer = 0;
let nextMouthToggle = 200 + Math.random() * 300;

function randomBlink() { return 120 + Math.random() * 200; } // frames between blinks

// â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// â”€â”€ Drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

function draw() {
  const W = canvas.width;
  const H = canvas.height;
  const scale = Math.min(W, H) / 200; // everything relative to 200-unit grid
  const cx = W / 2;
  const cy = H / 2;

  // Background
  const bg = COLORS[emotion] || COLORS.focused;
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // Gentle bob
  bobPhase += 0.02;
  const bobY = Math.sin(bobPhase) * scale * 3;

  // â”€â”€ Eyes (taller than wide â€” portrait rectangles) â”€â”€
  const eyeW = scale * 12;
  const eyeFullH = scale * 18;
  const eyeGap = scale * 20;
  const eyeY = cy - scale * 10 + bobY;

  // Target height based on emotion
  let targetH = eyeFullH;
  if (emotion === 'sleeping') {
    targetH = scale * 3;
  } else if (emotion === 'tired') {
    targetH = scale * 8;
  }

  // Smooth blink: lerp toward closed then back
  const blinkLerp = 1 - blinkProgress; // 1 = open, 0 = closed
  const finalEyeH = Math.max(scale * 2, targetH * blinkLerp);

  // Smooth look-around using layered sine waves (different speeds = natural drift)
  const lookX = Math.sin(tick * 0.012) * scale * 3 + Math.sin(tick * 0.005) * scale * 1.5;
  const lookY = Math.cos(tick * 0.009) * scale * 2 + Math.sin(tick * 0.004) * scale * 1;

  const leftEyeX = cx - eyeGap - eyeW / 2;
  const rightEyeX = cx + eyeGap - eyeW / 2;
  const eyeTopY = eyeY - finalEyeH / 2;

  // Draw eyes (solid dark blocks â€” no pupils, whole eye drifts to look around)
  drawRect(leftEyeX + lookX, eyeTopY + lookY, eyeW, finalEyeH, EYE_COLOR);
  drawRect(rightEyeX + lookX, eyeTopY + lookY, eyeW, finalEyeH, EYE_COLOR);

  // â”€â”€ Mouth â”€â”€
  const mouthY = cy + scale * 16 + bobY + lookY * 0.3;
  let mouthW = scale * 8;
  let mouthH = scale * 3;

  if (emotion === 'happy' || emotion === 'excited') {
    mouthW = scale * 14;
    mouthH = scale * 5;
  } else if (emotion === 'stressed') {
    mouthW = scale * 10;
    mouthH = scale * 2;
  } else if (emotion === 'sleeping' || emotion === 'tired') {
    mouthW = scale * 6;
    mouthH = scale * 1.5;
  }

  if (mouthVisible) {
    drawRect(cx - mouthW / 2 + lookX * 0.3, mouthY - mouthH / 2, mouthW, mouthH, EYE_COLOR);
  }

  // â”€â”€ Floating Z's (sleeping) â”€â”€
  if (emotion === 'sleeping') {
    const zSize = scale * 6;
    for (let i = 0; i < 3; i++) {
      const phase = (tick * 0.01 + i * 2) % 6;
      const zx = cx + scale * 30 + i * scale * 8;
      const zy = cy - scale * 30 - phase * scale * 10;
      const alpha = Math.max(0, 1 - phase / 6);
      const fontSize = Math.round(zSize * (1 + i * 0.3));
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillStyle = EYE_COLOR;
      ctx.globalAlpha = alpha;
      ctx.fillText('z', zx, zy + bobY);
    }
    ctx.globalAlpha = 1;
  }

  // â”€â”€ Particles (reactions) â”€â”€
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.y -= 2;
    p.life--;
    p.x += p.vx;
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.font = `${Math.round(scale * 8)}px sans-serif`;
    ctx.fillText(p.emoji, p.x, p.y);
    if (p.life <= 0) particles.splice(i, 1);
  }
  ctx.globalAlpha = 1;
}

// â”€â”€ Animation Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  tick++;

  // Smooth blink logic
  blinkTimer++;
  if (blinkTimer >= nextBlink && blinkDir === 0) {
    blinkDir = 1; // start closing
  }
  if (blinkDir === 1) {
    blinkProgress += 0.15; // closing speed
    if (blinkProgress >= 1) {
      blinkProgress = 1;
      blinkDir = -1; // start opening
    }
  } else if (blinkDir === -1) {
    blinkProgress -= 0.1; // opening speed (slightly slower)
    if (blinkProgress <= 0) {
      blinkProgress = 0;
      blinkDir = 0;
      blinkTimer = 0;
      nextBlink = randomBlink();
    }
  }

  // Mouth occasionally disappears
  mouthTimer++;
  if (mouthTimer >= nextMouthToggle) {
    mouthVisible = !mouthVisible;
    mouthTimer = 0;
    nextMouthToggle = mouthVisible
      ? 250 + Math.random() * 400  // visible for a while
      : 30 + Math.random() * 60;   // hidden briefly
  }

  draw();
  requestAnimationFrame(loop);
}
loop();

// â”€â”€ Interactions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
canvas.addEventListener('click', (e) => {
  // Spawn heart particle at click position
  spawnParticle(e.clientX * devicePixelRatio, e.clientY * devicePixelRatio, 'â¤ï¸');
  interact('pat');
});

function spawnParticle(x, y, emoji) {
  particles.push({
    x, y, emoji,
    vx: (Math.random() - 0.5) * 3,
    life: 60,
    maxLife: 60,
  });
}

function interact(action) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'interact', action }));
  }
}

// â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
const ws = new WebSocket(`${protocol}//${location.host}`);

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  if (msg.type === 'statusUpdate') {
    emotion = msg.data.emotion;
    task = msg.data.task;
    energy = msg.data.energy;
  }
  if (msg.type === 'interaction') {
    const W = canvas.width;
    const H = canvas.height;
    const emojis = { pat: 'â¤ï¸', tickle: 'ğŸ˜‚' };
    for (let i = 0; i < 5; i++) {
      spawnParticle(
        W / 2 + (Math.random() - 0.5) * W * 0.4,
        H / 2 + (Math.random() - 0.5) * H * 0.3,
        emojis[msg.action] || 'âœ¨'
      );
    }
  }
};
</script>
</body>
</html>
