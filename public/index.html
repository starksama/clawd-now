<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Stark</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ‚îÄ‚îÄ Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const COLORS = {
  sleeping: '#E8C9C0',
  focused:  '#E8937C',
  happy:    '#F0A896',
  excited:  '#E8754A',
  stressed: '#D97546',
  tired:    '#D9B5A8',
};
const EYE_COLOR = '#3D2817';
const PIXEL = 6; // base pixel size, scales with screen

// ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let emotion = 'sleeping';
let task = 'Resting peacefully...';
let energy = 100;
let tick = 0;
let blinkTimer = 0;
let isBlinking = false;
let nextBlink = randomBlink();
let particles = [];
let bobPhase = 0;

function randomBlink() { return 120 + Math.random() * 200; } // frames between blinks

// ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// ‚îÄ‚îÄ Drawing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}

function draw() {
  const W = canvas.width;
  const H = canvas.height;
  const scale = Math.min(W, H) / 200; // everything relative to 200-unit grid
  const cx = W / 2;
  const cy = H / 2;

  // Background
  const bg = COLORS[emotion] || COLORS.focused;
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // Gentle bob
  bobPhase += 0.02;
  const bobY = Math.sin(bobPhase) * scale * 3;

  // ‚îÄ‚îÄ Eyes ‚îÄ‚îÄ
  const eyeW = scale * 16;
  const eyeH = scale * 14;
  const eyeGap = scale * 22;
  const eyeY = cy - scale * 10 + bobY;

  // Sleeping/tired = half-closed, blink = fully closed
  let finalEyeH = eyeH;
  if (isBlinking) {
    finalEyeH = scale * 2;
  } else if (emotion === 'sleeping') {
    finalEyeH = scale * 3;
  } else if (emotion === 'tired') {
    finalEyeH = scale * 6;
  }

  // Smooth look-around using layered sine waves (different speeds = natural drift)
  const lookX = Math.sin(tick * 0.012) * scale * 3 + Math.sin(tick * 0.005) * scale * 1.5;
  const lookY = Math.cos(tick * 0.009) * scale * 2 + Math.sin(tick * 0.004) * scale * 1;

  const leftEyeX = cx - eyeGap - eyeW / 2;
  const rightEyeX = cx + eyeGap - eyeW / 2;
  const eyeTopY = eyeY - finalEyeH / 2;

  // Draw eye backgrounds (dark)
  drawRect(leftEyeX + lookX, eyeTopY + lookY, eyeW, finalEyeH, EYE_COLOR);
  drawRect(rightEyeX + lookX, eyeTopY + lookY, eyeW, finalEyeH, EYE_COLOR);

  // Draw pupils (white highlight) ‚Äî only when eyes are open enough
  if (finalEyeH > scale * 5) {
    const pupilW = scale * 5;
    const pupilH = scale * 5;
    // Pupil moves WITHIN the eye (smaller range, offset from look direction)
    const pupilOffX = Math.sin(tick * 0.015) * scale * 2.5;
    const pupilOffY = Math.cos(tick * 0.011) * scale * 1.5;
    const pupilColor = '#F5D6C8'; // slightly lighter than background

    // Left pupil
    drawRect(
      leftEyeX + lookX + eyeW / 2 - pupilW / 2 + pupilOffX,
      eyeTopY + lookY + finalEyeH / 2 - pupilH / 2 + pupilOffY,
      pupilW, pupilH, pupilColor
    );
    // Right pupil
    drawRect(
      rightEyeX + lookX + eyeW / 2 - pupilW / 2 + pupilOffX,
      eyeTopY + lookY + finalEyeH / 2 - pupilH / 2 + pupilOffY,
      pupilW, pupilH, pupilColor
    );
  }

  // ‚îÄ‚îÄ Mouth ‚îÄ‚îÄ
  const mouthY = cy + scale * 16 + bobY + lookY * 0.3;
  let mouthW = scale * 8;
  let mouthH = scale * 3;

  if (emotion === 'happy' || emotion === 'excited') {
    mouthW = scale * 14;
    mouthH = scale * 5;
  } else if (emotion === 'stressed') {
    mouthW = scale * 10;
    mouthH = scale * 2;
  } else if (emotion === 'sleeping' || emotion === 'tired') {
    mouthW = scale * 6;
    mouthH = scale * 1.5;
  }

  drawRect(cx - mouthW / 2 + lookX * 0.3, mouthY - mouthH / 2, mouthW, mouthH, EYE_COLOR);

  // ‚îÄ‚îÄ Floating Z's (sleeping) ‚îÄ‚îÄ
  if (emotion === 'sleeping') {
    const zSize = scale * 6;
    for (let i = 0; i < 3; i++) {
      const phase = (tick * 0.01 + i * 2) % 6;
      const zx = cx + scale * 30 + i * scale * 8;
      const zy = cy - scale * 30 - phase * scale * 10;
      const alpha = Math.max(0, 1 - phase / 6);
      const fontSize = Math.round(zSize * (1 + i * 0.3));
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillStyle = EYE_COLOR;
      ctx.globalAlpha = alpha;
      ctx.fillText('z', zx, zy + bobY);
    }
    ctx.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ Particles (reactions) ‚îÄ‚îÄ
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.y -= 2;
    p.life--;
    p.x += p.vx;
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.font = `${Math.round(scale * 8)}px sans-serif`;
    ctx.fillText(p.emoji, p.x, p.y);
    if (p.life <= 0) particles.splice(i, 1);
  }
  ctx.globalAlpha = 1;
}

// ‚îÄ‚îÄ Animation Loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loop() {
  tick++;

  // Blink logic
  blinkTimer++;
  if (blinkTimer >= nextBlink && !isBlinking) {
    isBlinking = true;
    setTimeout(() => {
      isBlinking = false;
      blinkTimer = 0;
      nextBlink = randomBlink();
    }, 120);
  }

  draw();
  requestAnimationFrame(loop);
}
loop();

// ‚îÄ‚îÄ Interactions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
canvas.addEventListener('click', (e) => {
  // Spawn heart particle at click position
  spawnParticle(e.clientX * devicePixelRatio, e.clientY * devicePixelRatio, '‚ù§Ô∏è');
  interact('pat');
});

function spawnParticle(x, y, emoji) {
  particles.push({
    x, y, emoji,
    vx: (Math.random() - 0.5) * 3,
    life: 60,
    maxLife: 60,
  });
}

function interact(action) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'interact', action }));
  }
}

// ‚îÄ‚îÄ WebSocket ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
const ws = new WebSocket(`${protocol}//${location.host}`);

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  if (msg.type === 'statusUpdate') {
    emotion = msg.data.emotion;
    task = msg.data.task;
    energy = msg.data.energy;
  }
  if (msg.type === 'interaction') {
    const W = canvas.width;
    const H = canvas.height;
    const emojis = { pat: '‚ù§Ô∏è', tickle: 'üòÇ' };
    for (let i = 0; i < 5; i++) {
      spawnParticle(
        W / 2 + (Math.random() - 0.5) * W * 0.4,
        H / 2 + (Math.random() - 0.5) * H * 0.3,
        emojis[msg.action] || '‚ú®'
      );
    }
  }
};
</script>
</body>
</html>
