<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Stark</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// ── Config ──────────────────────────────────────────
const COLORS = {
  sleeping: '#E8C9C0',
  focused:  '#E8937C',
  happy:    '#F0A896',
  excited:  '#E8754A',
  stressed: '#D97546',
  tired:    '#D9B5A8',
};
const EYE_COLOR = '#3D2817';

// ── State ───────────────────────────────────────────
let emotion = 'sleeping';
let task = 'Resting peacefully...';
let energy = 100;
let tick = 0;

// Animation state — one unified "openness" drives everything
let openness = 1.0;       // 0 = fully closed (flat bar), 1 = fully open (square)
let targetOpenness = 1.0;
let mouthShow = 0.0;      // 0 = hidden, 1 = fully visible
let targetMouth = 0.0;

// Scheduling
let nextEvent = 60;        // frames until next animation event
let currentPhase = 'idle'; // idle, closing, closed, opening

// ── Canvas ──────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// ── Smooth lerp ─────────────────────────────────────
function lerp(a, b, t) { return a + (b - a) * t; }

// ── Drawing ─────────────────────────────────────────
function draw() {
  const W = canvas.width;
  const H = canvas.height;
  const scale = Math.min(W, H) / 200;
  const cx = W / 2;
  const cy = H / 2;

  // Background
  const bg = COLORS[emotion] || COLORS.focused;
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  // Gentle bob
  const bobY = Math.sin(tick * 0.015) * scale * 2.5;

  // Smooth eye drift (look around)
  const lookX = Math.sin(tick * 0.008) * scale * 3 + Math.sin(tick * 0.003) * scale * 1.5;
  const lookY = Math.cos(tick * 0.006) * scale * 1.5 + Math.sin(tick * 0.0025) * scale * 0.8;

  // ── Eyes ──
  const eyeW = scale * 14;
  const eyeMaxH = scale * 16;   // fully open = nearly square
  const eyeMinH = scale * 3;    // fully closed = flat bar
  const eyeH = lerp(eyeMinH, eyeMaxH, openness);
  const eyeGap = scale * 20;
  const eyeY = cy - scale * 8 + bobY + lookY;

  ctx.fillStyle = EYE_COLOR;
  // Left eye
  ctx.fillRect(
    Math.round(cx - eyeGap - eyeW / 2 + lookX),
    Math.round(eyeY - eyeH / 2),
    Math.round(eyeW),
    Math.round(eyeH)
  );
  // Right eye
  ctx.fillRect(
    Math.round(cx + eyeGap - eyeW / 2 + lookX),
    Math.round(eyeY - eyeH / 2),
    Math.round(eyeW),
    Math.round(eyeH)
  );

  // ── Mouth ── (coordinated with eyes)
  if (mouthShow > 0.02) {
    const mouthW = scale * 8;
    const mouthMaxH = scale * 4;
    const mouthH = mouthMaxH * mouthShow;
    const mouthY = cy + scale * 16 + bobY + lookY * 0.3;

    ctx.globalAlpha = mouthShow;
    ctx.fillStyle = EYE_COLOR;
    ctx.fillRect(
      Math.round(cx - mouthW / 2 + lookX * 0.3),
      Math.round(mouthY - mouthH / 2),
      Math.round(mouthW),
      Math.round(mouthH)
    );
    ctx.globalAlpha = 1;
  }

  // ── Floating Z's (sleeping) ──
  if (emotion === 'sleeping' && openness < 0.4) {
    const zSize = scale * 6;
    for (let i = 0; i < 3; i++) {
      const phase = (tick * 0.008 + i * 2) % 6;
      const zx = cx + scale * 28 + i * scale * 8;
      const zy = cy - scale * 25 - phase * scale * 10;
      const alpha = Math.max(0, 1 - phase / 6);
      const fontSize = Math.round(zSize * (1 + i * 0.3));
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillStyle = EYE_COLOR;
      ctx.globalAlpha = alpha * 0.6;
      ctx.fillText('z', zx, zy + bobY);
    }
    ctx.globalAlpha = 1;
  }
}

// ── Animation Logic ─────────────────────────────────
function scheduleNext() {
  // Random delay between events
  nextEvent = 80 + Math.random() * 200;
}

function updateAnimation() {
  // Smoothly move toward targets
  openness = lerp(openness, targetOpenness, 0.04);
  mouthShow = lerp(mouthShow, targetMouth, 0.05);

  nextEvent--;
  if (nextEvent <= 0) {
    // Choose next animation phase
    if (currentPhase === 'idle') {
      // Sometimes blink (quick close-open)
      // Sometimes do a slow squint
      // Sometimes toggle mouth
      const r = Math.random();

      if (r < 0.35) {
        // Quick blink
        currentPhase = 'blinking';
        targetOpenness = 0;
        nextEvent = 12; // short hold
      } else if (r < 0.55) {
        // Slow squint (close halfway, hold, reopen)
        currentPhase = 'squinting';
        targetOpenness = 0.15;
        nextEvent = 40 + Math.random() * 60;
      } else if (r < 0.75) {
        // Toggle mouth
        targetMouth = targetMouth > 0.5 ? 0 : 1;
        currentPhase = 'idle';
        scheduleNext();
      } else {
        // Just wait
        scheduleNext();
      }
    } else if (currentPhase === 'blinking') {
      // Open back up
      targetOpenness = getEmotionOpenness();
      currentPhase = 'idle';
      scheduleNext();
    } else if (currentPhase === 'squinting') {
      // Open back up, maybe change mouth
      targetOpenness = getEmotionOpenness();
      // Mouth often appears/disappears with squint transitions
      if (Math.random() < 0.5) {
        targetMouth = targetMouth > 0.5 ? 0 : 1;
      }
      currentPhase = 'idle';
      scheduleNext();
    }
  }

  // Mouth tends to hide when eyes are very closed
  if (openness < 0.25 && targetMouth > 0.5) {
    targetMouth = 0;
  }
}

function getEmotionOpenness() {
  switch (emotion) {
    case 'sleeping': return 0.15;
    case 'tired': return 0.45;
    case 'stressed': return 0.7;
    default: return 1.0;
  }
}

// ── Main Loop ───────────────────────────────────────
function loop() {
  tick++;
  updateAnimation();
  draw();
  requestAnimationFrame(loop);
}
loop();

// ── WebSocket ───────────────────────────────────────
const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
const ws = new WebSocket(`${protocol}//${location.host}`);

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  if (msg.type === 'statusUpdate') {
    emotion = msg.data.emotion;
    task = msg.data.task;
    energy = msg.data.energy;
    // Update eye target based on new emotion
    targetOpenness = getEmotionOpenness();
  }
};
</script>
</body>
</html>
